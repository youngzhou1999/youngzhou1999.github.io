---
  
layout: post
  
title: 集合划分问题时间复杂度分析
  
categories: Blog
  
description: Algorithm, time complexity 
  
keywords: Set division, complexity theory
  
---







## 集合划分问题



给定正整数$n,m$，计算出$n$个元素的集合$\{1,2,\cdots,n\}$可以划分为多少个不同的由$m$个非空子集合组成的集合。



#### (1)解题原理



根据题目所给的划分规则，设$s[n][m]$为$n$个元素划分为$m$个非空子集的集合的个数，则我们从两方面来考虑这个数量的由来：



​		(1)固定$n-1$个元素，考虑最后一个元素的单独划分：考虑$s[n-1][m-1]$，其表示将$n-1$个元素划分为$m-1$个非空集合，则我们只需要将剩下的那一个元素单独作为一个集合即可得到$m$个非空集合的$n$个元素的划分；



​		(2)固定$m$种划分，考虑最后一个元素的加入情况：考虑$s[n-1][m]$，其表示将$n-1$个元素划分为$m$个非空集合，则我们需要考虑剩下的那个元素进入哪一个集合，显然共有$m$种情况



​		因此，我们可以得到下面的计算式：

$$
  
s[n][m]=s[n-1][m-1]+m*s[n-1][m]
  
$$

​		其中，有退化结果：

$$
  
s[0][j]=0,s[i][1]=1,s[i][i]=1,s[i][j]=0(i<j)
  
$$

​		从而我们可以使用分治递归算法或打表记录的方法得到最后划分情况。



#### (2)解题步骤



若使用打表法：



​	Ⅰ.初始化$s$数组



​	Ⅱ.双重$for$循环遍历，填充对应位置处的$s[i][j]$的值



​	Ⅲ.输出结果至输出文件，并记录程序运行时间



分治递归法：



​	Ⅰ.设置递归基：`if(n==0||n<m)return 0;`和`if(m==1||m==n)return 1;`



​	Ⅱ.递归计算$s[i][j]$，即`return m*s[n-1][m]+s[n-1][m-1]`



​	Ⅲ.输出结果至输出文件，并记录程序运行时间

#### 关键代码



```c++
unsigned long long f(int n,int m){		//分治递归法
    if(m==0||m>n)return 0;
    if(m==1||m==n)return 1;
    return m*f(n-1,m)+f(n-1,m-1);
}
```



```c++
for(int i=0;i<=n;i++)					//初始化  
    for(int j=0;j<=m;j++){
        a[i][j]=0;
        if(i==j)a[i][j]=1;
    }	
for(int i=1;i<=n;i++)					//打表记录法
    for(int j=1;j<=m;j++){
        if(i>=j)
            a[i][j]=j*a[i-1][j]+a[i-1][j-1];
        else a[i][j]=0;
    }
```



#### 测试结果


<center>
    <img src="/images/posts/blog/set division/ans.png" alt="picture not found" style="zoom:100%;" />
    <br>
</center>



### (3)复杂度分析



​		打表记录法：由关键代码的双重$for$循环，可得其时间复杂度为$O(nm)$



​		分治递归法：其时间复杂函数$T(n,m)$存在一个下界$\Omega(min\{2^{n-m},2^{m-1}\})$，存在一个上界$O(2^{n-1})$即分支递归法解集合划分问题的时间复杂度为指数级。



### 附分治递归法的时间复杂度证明



由计算式：$s[n][m]=s[n-1][m-1]+m*s[n-1][m]$，得到：

$$
  
T(n,m)=T(n-1，m-1)+T(n-1,m)
  
$$



#### 下界 	



​		其解可视作一棵二叉树，每个状态都有两种不同的子状态，考虑其下界，即一直走左子节点或右子节点，即有：



##### a.一直走左子节点



$$
  
T(n,m)\approx{T(n-1,m-1)+T(n-1,m-1)}=2T(n-1,m-1)
  
$$



​		由题有$n>m$，利用乘法消项：

$$
  
T(n,m)=2T(n-1,m-1)\\2T(n-1,m-1)=2^2{T(n-2,m-2)}\\\cdots\\\cdots\\{2^{m-2}T(n-m+2,2)=2^{m-1}T(n-m+1,1)}
  
$$

​		由之前列出的退化结果，其出口为$s[i][1]=1$于是可以得到：

$$
  
T(n,m)=2^{m-1}T(n-m+1,1)=2^{m-1}
  
$$



##### $b.$一直走右子节点



$$
  
T(n,m)\approx{T(n-1,m)+T(n-1,m)}=2T(n-1,m)
  
$$



​	同理有$n>m$，利用乘法消项：

$$
  
T(n,m)=2T(n-1,m)\\2T(n-1,m)=2^2{T(n-2,m)}\\\cdots\\\cdots\\{2^{n-(m+1)}T(m+1,m)=2^{n-m}T(m,m)}
  
$$

​	由之前的退化结果，可以得此时的出口为$s[i][i]=1$于是我们可以得到：

$$
T(n,m)=2^{n-m}T(m,m)=2^{n-m}
$$

​	因此我们得到此方法的下界为：

$$
  
T(n,m)=\Omega(min\{2^{n-m},2^{m-1}\})
  
$$



#### 上界



​		考虑解在二叉树左右子节点反复横跳的情况，不难得出极端情况为：一次左，一次右，因此我们可以将之前计算的单走某一支的情况相乘即表示所有可能的情况。



​		不难得出，其上界为：

$$
  
T(n,m)=2^{n-m}\times2^{m-1}=O(2^{n-1})
  
$$



  
